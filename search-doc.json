[{"title":"General","type":0,"sectionRef":"#","url":"/vetersutil/api/General","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"General","url":"/vetersutil/api/General#functions","content":" "},{"title":"printf​","type":1,"pageTitle":"General","url":"/vetersutil/api/General#printf","content":"&lt;/&gt; General.printf( formatString: string,-- The string to format ...: any-- The variables to format with ) → () Formats formatString and prints it to the output. Just a string.format wrapper lol. "},{"title":"How to Contribute","type":0,"sectionRef":"#","url":"/vetersutil/docs/How-to-Contribute","content":"","keywords":""},{"title":"Contributing - The tools we use​","type":1,"pageTitle":"How to Contribute","url":"/vetersutil/docs/How-to-Contribute#contributing---the-tools-we-use","content":"Before contributing to vetersutil, consider famaliarizing yourself with these tools: moonwaverojoaftmanwally "},{"title":"Contributing - Filesystem​","type":1,"pageTitle":"How to Contribute","url":"/vetersutil/docs/How-to-Contribute#contributing---filesystem","content":"The filesystem is relatively simple to follow. All utilities are located in /root/packages/ and in their own designated folder. Inside of those folders will be an init.luau file and a wally.toml file. It may include a INFO.md file which might explain package-specific things. "},{"title":"How to Issues","type":0,"sectionRef":"#","url":"/vetersutil/docs/How-to-Issues","content":"","keywords":""},{"title":"Tips​","type":1,"pageTitle":"How to Issues","url":"/vetersutil/docs/How-to-Issues#tips","content":"Issues should include relevant details such as Run Context. Next, include the version you're using and whether you copy and pasted it or used wally. Include the package, the function and the snippet of code where you're receiving the error as well as the error message word for word. At this point in time, if you are using these libraries with lune, please expect some functions not to work. "},{"title":"Intro","type":0,"sectionRef":"#","url":"/vetersutil/docs/intro","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Intro","url":"/vetersutil/docs/intro#installation","content":"All packages can be installed via wally. You can go to the &quot;packages&quot; section to see a full list of packages and their path in the wally index. "},{"title":"Packages","type":0,"sectionRef":"#","url":"/vetersutil/docs/Packages","content":"Packages In this section is a list of packages, their wally path and a brief description. Name\tWally Path\tDescriptionTable\tTable = veternitzzz/vt-table@1.0.0\tA fork of sleitnick's table util with added functionality. General\tGeneral = veternitzz/vt-general@1.0.0\tGeneral purpose functions that can be used in a variety of situations.","keywords":""},{"title":"Table","type":0,"sectionRef":"#","url":"/vetersutil/api/Table","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#functions","content":" "},{"title":"set​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#set","content":"&lt;/&gt; Table.set( tbl: {}-- The table to remove all duplicate values in ) → {} Returns a clone of tbl, having removed all duplicate values. Pulled this one straight from python.  "},{"title":"any​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#any","content":"&lt;/&gt; Table.any( tbl: {}-- The table to check ) → boolean Checks tbl and returns true if any of the values in the table are true.  "},{"title":"all​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#all","content":"&lt;/&gt; Table.all( tbl: {}-- The table to check ) → boolean Checks tbl and returns true if all of the values in the table are true. Ignores non-boolean values. Also returns false if there are no boolean values.  "},{"title":"getValuesOfType​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#getValuesOfType","content":"&lt;/&gt; Table.getValuesOfType( tbl: {},-- The table to look through Type: string-- The type to check for ) → {} | nil Looks through tbl and returns all a table containing the values which are the type specified by Type. Returns nil if none match Type.  "},{"title":"Copy​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Copy","content":"&lt;/&gt; Table.Copy( tbl: table,-- Table to copy deep: boolean?-- Whether or not to perform a deep copy ) → table Creates a copy of the given table. By default, a shallow copy is performed. For deep copies, a second boolean argument must be passed to the function. No cyclical references Deep copies are not protected against cyclical references. Passing a table with cyclical references and the deep parameter set to true will result in a stack-overflow.  "},{"title":"Sync​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Sync","content":"&lt;/&gt; Table.Sync( srcTbl: table,-- Source table templateTbl: table-- Template table ) → table Synchronizes the srcTbl based on the templateTbl. This will make sure that srcTbl has all of the same keys as templateTbl, including removing keys in srcTbl that are not present in templateTbl. This is a deep operation, so any nested tables will be synchronized as well. local template = {kills = 0, deaths = 0, xp = 0} local data = {kills = 10, experience = 12} data = Table.Sync(data, template) print(data) --&gt; {kills = 10, deaths = 0, xp = 0} Data Loss Warning This is a two-way sync, so the source table will have dataremoved that isn't found in the template table. This can be problematic if used for player data, where there might be dynamic data added that isn't in the template. For player data, use Table.Reconcile instead.  "},{"title":"Reconcile​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Reconcile","content":"&lt;/&gt; Table.Reconcile( source: table, template: table ) → table Performs a one-way sync on the source table against the template table. Any keys found in template that are not found in source will be added to source. This is useful for syncing player data against data template tables to ensure players have all the necessary keys, while maintaining existing keys that may no longer be in the template. This is a deep operation, so nested tables will also be properly reconciled. local template = {kills = 0, deaths = 0, xp = 0} local data = {kills = 10, abc = 20} local correctedData = Table.Reconcile(data, template) print(correctedData) --&gt; {kills = 10, deaths = 0, xp = 0, abc = 20}   "},{"title":"SwapRemove​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#SwapRemove","content":"&lt;/&gt; Table.SwapRemove( tbl: table,-- Array i: number-- Index ) → () Removes index i in the table by swapping the value at i with the last value in the array, and then trimming off the last value from the array. This allows removal of the value at i in O(1) time, but does not preserve array ordering. If a value needs to be removed from an array, but ordering of the array does not matter, using SwapRemove is always preferred over table.remove. In the following example, we remove &quot;B&quot; at index 2. SwapRemove does this by moving the last value &quot;E&quot; over top of &quot;B&quot;, and then trimming off &quot;E&quot; at the end of the array: local t = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;} Table.SwapRemove(t, 2) -- Remove &quot;B&quot; print(t) --&gt; {&quot;A&quot;, &quot;E&quot;, &quot;C&quot;, &quot;D&quot;} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"SwapRemoveFirstValue​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#SwapRemoveFirstValue","content":"&lt;/&gt; Table.SwapRemoveFirstValue( tbl: table,-- Array v: any-- Value to find ) → number? Performs table.find(tbl, v) to find the index of the given value, and then performs Table.SwapRemove on that index. local t = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;} Table.SwapRemoveFirstValue(t, &quot;C&quot;) print(t) --&gt; {&quot;A&quot;, &quot;B&quot;, &quot;E&quot;, &quot;D&quot;} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Map​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Map","content":"&lt;/&gt; Table.Map( tbl: table, predicate: ( value: any, key: any, tbl: table ) → newValue: any ) → table Performs a map operation against the given table, which can be used to map new values based on the old values at given keys/indices. For example: local t = {A = 10, B = 20, C = 30} local t2 = Table.Map(t, function(value) return value * 2 end) print(t2) --&gt; {A = 20, B = 40, C = 60}   "},{"title":"Filter​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Filter","content":"&lt;/&gt; Table.Filter( tbl: table, predicate: ( value: any, key: any, tbl: table ) → keep: boolean ) → table Performs a filter operation against the given table, which can be used to filter out unwanted values from the table. For example: local t = {A = 10, B = 20, C = 30} local t2 = Table.Filter(t, function(value, key) return value &gt; 15 end) print(t2) --&gt; {B = 40, C = 60}   "},{"title":"Reduce​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Reduce","content":"&lt;/&gt; Table.Reduce( tbl: table, predicate: ( accumulator: any, value: any, index: any, tbl: table ) → result: any ) → table Performs a reduce operation against the given table, which can be used to reduce the table into a single value. This could be used to sum up a table or transform all the values into a compound value of any kind. For example: local t = {10, 20, 30, 40} local result = Table.Reduce(t, function(accum, value) return accum + value end) print(result) --&gt; 100   "},{"title":"Assign​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Assign","content":"&lt;/&gt; Table.Assign( target: table, ...: table ) → table Copies all values of the given tables into the target table. local t = {A = 10} local t2 = {B = 20} local t3 = {C = 30, D = 40} local newT = Table.Assign(t, t2, t3) print(newT) --&gt; {A = 10, B = 20, C = 30, D = 40}   "},{"title":"Extend​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Extend","content":"&lt;/&gt; Table.Extend( target: table, extension: table ) → table Extends the target array with the extension array. local t = {10, 20, 30} local t2 = {30, 40, 50} local tNew = Table.Extend(t, t2) print(tNew) --&gt; {10, 20, 30, 30, 40, 50} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Reverse​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Reverse","content":"&lt;/&gt; Table.Reverse(tbl: table) → table Reverses the array. local t = {1, 5, 10} local tReverse = Table.Reverse(t) print(tReverse) --&gt; {10, 5, 1} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Shuffle​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Shuffle","content":"&lt;/&gt; Table.Shuffle( tbl: table, rngOverride: Random? ) → table Shuffles the table. local t = {1, 2, 3, 4, 5, 6, 7, 8, 9} local shuffled = Table.Shuffle(t) print(shuffled) --&gt; e.g. {9, 4, 6, 7, 3, 1, 5, 8, 2} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Sample​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Sample","content":"&lt;/&gt; Table.Sample( tbl: table, sampleSize: number, rngOverride: Random? ) → table Returns a random sample of the table. local t = {1, 2, 3, 4, 5, 6, 7, 8, 9} local sample = Table.Sample(t, 3) print(sample) --&gt; e.g. {6, 2, 5} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Flat​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Flat","content":"&lt;/&gt; Table.Flat( tbl: table, depth: number? ) → table Returns a new table where all sub-arrays have been bubbled up to the top. The depth at which the scan is performed is dictated by the depth parameter, which is set to 1 by default. local t = {{10, 20}, {90, 100}, {30, 15}} local flat = Table.Flat(t) print(flat) --&gt; {10, 20, 90, 100, 30, 15} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"FlatMap​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#FlatMap","content":"&lt;/&gt; Table.FlatMap( tbl: table, predicate: ( key: any, value: any, tbl: table ) → newValue: any ) → table Calls Table.Map on the given table and predicate, and then calls Table.Flat on the result from the map operation. local t = {10, 20, 30} local result = Table.FlatMap(t, function(value) return {value, value * 2} end) print(result) --&gt; {10, 20, 20, 40, 30, 60} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Keys​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Keys","content":"&lt;/&gt; Table.Keys(tbl: table) → table Returns an array with all the keys in the table. local t = {A = 10, B = 20, C = 30} local keys = Table.Keys(t) print(keys) --&gt; {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;} Ordering The ordering of the keys is never guaranteed. If order is imperative, calltable.sort on the resulting keys array. local keys = Table.Keys(t) table.sort(keys)   "},{"title":"Values​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Values","content":"&lt;/&gt; Table.Values(tbl: table) → table Returns an array with all the values in the table. local t = {A = 10, B = 20, C = 30} local values = Table.Values(t) print(values) --&gt; {10, 20, 30} Ordering The ordering of the values is never guaranteed. If order is imperative, calltable.sort on the resulting values array. local values = Table.Values(t) table.sort(values)   "},{"title":"Find​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Find","content":"&lt;/&gt; Table.Find( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → ( value: any?, key: any? ) Performs a linear scan across the table and calls callback on each item in the array. Returns the value and key of the first pair in which the callback returns true. local t = { {Name = &quot;Bob&quot;, Age = 20}; {Name = &quot;Jill&quot;, Age = 30}; {Name = &quot;Ann&quot;, Age = 25}; } -- Find first person who has a name starting with J: local firstPersonWithJ = Table.Find(t, function(person) return person.Name:sub(1, 1):lower() == &quot;j&quot; end) print(firstPersonWithJ) --&gt; {Name = &quot;Jill&quot;, Age = 30} Dictionary Ordering While Find can also be used with dictionaries, dictionary ordering is never guaranteed, and thus the result could be different if there are more than one possible matches given the data and callback function.  "},{"title":"Every​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Every","content":"&lt;/&gt; Table.Every( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → boolean Returns true if the callback also returns true for every item in the table. local t = {10, 20, 40, 50, 60} local allAboveZero = Table.Every(t, function(value) return value &gt; 0 end) print(&quot;All above zero:&quot;, allAboveZero) --&gt; All above zero: true   "},{"title":"Some​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Some","content":"&lt;/&gt; Table.Some( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → boolean Returns true if the callback also returns true for at least one of the items in the table. local t = {10, 20, 40, 50, 60} local someBelowTwenty = Table.Some(t, function(value) return value &lt; 20 end) print(&quot;Some below twenty:&quot;, someBelowTwenty) --&gt; Some below twenty: true   "},{"title":"Truncate​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Truncate","content":"&lt;/&gt; Table.Truncate( tbl: table, length: number ) → table Returns a new table truncated to the length of length. Any length equal or greater than the current length will simply return a shallow copy of the table. local t = {10, 20, 30, 40, 50, 60, 70, 80} local tTruncated = Table.Truncate(t, 3) print(tTruncated) --&gt; {10, 20, 30}   "},{"title":"Zip​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Zip","content":"&lt;/&gt; Table.Zip(...: table) → ( iter: ( t: table, k: any ) → ( key: any?, values: table? ), tbl: table, startIndex: any? ) Returns an iterator that can scan through multiple tables at the same time side-by-side, matching against shared keys/indices. local t1 = {10, 20, 30, 40, 50} local t2 = {60, 70, 80, 90, 100} for key,values in Table.Zip(t1, t2) do print(key, values) end --[[ Outputs: 1 {10, 60} 2 {20, 70} 3 {30, 80} 4 {40, 90} 5 {50, 100} --]]   "},{"title":"Lock​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#Lock","content":"&lt;/&gt; Table.Lock(tbl: table) → table Locks the table using table.freeze, as well as any nested tables within the given table. This will lock the whole deep structure of the table, disallowing any further modifications. local tbl = {xyz = {abc = 32}} tbl.xyz.abc = 28 -- Works fine Table.Lock(tbl) tbl.xyz.abc = 64 -- Will throw an error (cannot modify readonly table)   "},{"title":"IsEmpty​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#IsEmpty","content":"&lt;/&gt; Table.IsEmpty(tbl: table) → boolean Returns true if the given table is empty. This is simply performed by checking if next(tbl) is nil and works for both arrays and dictionaries. This is useful when needing to check if a table is empty but not knowing if it is an array or dictionary. Table.IsEmpty({}) -- true Table.IsEmpty({&quot;abc&quot;}) -- false Table.IsEmpty({abc = 32}) -- false   "},{"title":"EncodeJSON​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#EncodeJSON","content":"&lt;/&gt; Table.EncodeJSON(value: any) → string Proxy for HttpService:JSONEncode.  "},{"title":"DecodeJSON​","type":1,"pageTitle":"Table","url":"/vetersutil/api/Table#DecodeJSON","content":"&lt;/&gt; Table.DecodeJSON(value: any) → string Proxy for HttpService:JSONDecode. "}]